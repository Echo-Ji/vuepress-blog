---
title:          前端问答
date:           2020-09-21
author:         Echo
location:       Beijing 
tags: 
    - 前端
    - 面试
    - JS
---

## Q1：在JavaScript 中，null 与 undefined 的异同点是什么呢？

他们都是原始类型。

* undefined：是所有未赋值变量的默认值，自动赋值。
* null：主动释放一个变量引用的对象，表示一个变量不再指向任何对象地址。

当使用完一个比较大的对象时，用 null 对其进行内存释放 `foo = null`。

```Javascript
var person = null;          // 值为 null(空), 但类型为对象
var person;                 // 值为 undefined，类型为 undefined
person = undefined;         // 值为 undefined，类型为 undefined
```
null 和 undefined 的值相等，但类型不等。

```Javascript
typeof undefined             // undefined
typeof null                  // object
null === undefined           // false
null == undefined            // true
```

## Q2：状态码301和302的区别。

都是重定向，但是
* 301 永久性转移，搜索引擎在抓取新内容的同时也将旧的网址替换为重定向之后的网址。
* 302 临时性转移，搜索引擎会抓取新的内容而保留旧的网址。

<!-- ## Q3：强缓存引起问题的解决方案（如何更新网站资源）。

强缓存是导致服务器资源更新后，客户端得到的资源依旧是缓存中旧版的东西。
要解决这个问题
大公司的静态资源优化方案：
* 配置超长时间的本地缓存 —— 节省带宽，提高性能
* 采用内容摘要作为缓存更新依据 —— 精确的缓存控制
* 静态资源 CDN 部署 —— 优化网络请求
* 更新资源发布路径实现非覆盖式发布 —— 平滑升级 -->

## Q3: require 模块加载顺序。

* 优先加载内置模块，即使有同名手写模块。
* 去缓存寻找模块。
* 缓存没有就去找对应路径的文件。
* 不存在相应文件，就把该路径当作文件夹加载。
* 文件夹也没有就去 `node_modules` 下面找。
* 还没有就报错。

:warning: 加载文件夹也有顺序：
* 先看文件夹下有没有 `package.json`，有的话就找里面的 `main` 字段对应的文件。
* 如果没有 `package.json` 文件或者该文件里没有 `main` 字段就找 `index.js`。
* 否则返回（报错）。

在运行 `require` 和 `module.exports` 之前会先有一个空对象 `{}`（其实就是缓存），然后每 require 一个文件，会先运行目标文件，然后按照 `'文件名': 'module.exports'` 的键值对插入到全局的对象（缓存）中去，用的时候拿出来就好。

## Q4：JS 如何写面向对象。

函数作为类使用，也是构造函数。

用类的 `portotype` 来添加类方法。若要定义静态方法，则直接将它作为类函数的属性即可。

类的实例用 `__porto__` 查找类方法。其实原型的 `__porto__` 指向了父类的 `portotype`。

```JavaScript
// 函数作为类使用，也是构造函数。
function Puppy(age) {
    this.puppyAge = age; // this 总是指向实例对象，这里指向 myPuppy
}
// 添加类方法。
Puppy.portotype.say = function() {
    console.log('bark');
}
// 添加静态方法
Puppy.Puppy.staticFunc = function(){}
// new 一个对象相当于创建子类原型
const myPuppy = new Puppy(2);
console.log(myPuppy.__porto__ === Puppy.portotype) // true
```
参考 [1](https://juejin.im/post/6844904069887164423)。

### 实现 new

注意三点：
* 创建新对象并继承原型
* 执行构造函数并绑定 `this`
* 返回新对象

```JavaScript
function myNew(fn, ...args)
{
    // 相当于 newObj.__porto__ = fn.prototype;
    var newObj = Object.create(fn.prototype);

    var result = fn.apply(newObj, args);
    // [基础类型, 子类型], result 是否为 Object（子类型）
    return Object.prototype.toString.call(result) === '[Object Object]'? result: newObj;
}
```

### 实现继承

* 原型链继承：`Child.prototype = new Parent(); Child.prototype.constructor = Child;`，所有的子类实例都拥有**同一个父类引用**，如果修改其中一个的父类属性其他的也会跟着变；**无法向父类构造函数传参**。
* 构造函数继承：`Parent.call(this, ...args)`，**无法访问父类原型的属性和方法**。
* 组合式继承：组合前两种继承方式，但是每次新建对象会调用两次构造函数，使得子类实例存在两份相同的属性和方法。
* 寄生式组合继承：将指向父类实例改为指向父类原型即可减少一次构造函数调用，同时为了避免对子类型的操作影响父类型，对父类型原型做浅拷贝，`Child.prototype = Object.create(Parent.prototype)`。

## Q6: 解构赋值是什么？

解构赋值可以将属性/值从对象/数组中取出，赋值给其他变量。

注意在对象的声明解构中，需要用小括号将其包围，如果前面有语句的话，必须以分号结尾。

## Q7：箭头函数。

* 箭头函数写代码拥有更加简洁的语法
* 箭头函数不会绑定 `this`，或者说箭头函数中不会改变 `this` 原来的绑定，因此当箭头函数中有 `this` 时，他会寻找上一级作用域的 `this` 对象。

## Q8：JS 构成。

* ECMAScript 描述 JS 语言的规范
* DOM 描述了处理网页内容的方法和接口
* BOM 描述了与浏览器交互的方法和接口

## Q9：Webpack 是什么？

Webpack 是一种 JS 应用程序的静态模块打包器。

在处理应用程序时，它可以递归地构建模块之间的依赖图，然后根据依赖关系将所有模块打包成一个或多个静态资源，方便浏览器运行。

> 为什么需要 Webpack 呢？

随着 Web 前端的发展，新的思想新的技术新的框架不断涌现，最值得一提的比如前端模块化，新技术的确便利了开发人员，但却导致各个浏览器的更新压力巨大，他们也不能保证所有新的技术在自家浏览器上能够适用，因而出现了 Webpack，用于将源代码转化为可以直接在浏览器上运行的代码。

> 关于模块化。

随着前端复杂度不断提高，相互之间的依赖也越来越多，使得前端也不得不用模块化思想来组织代码。模块化的思想解决了前端的几个痛点：
* 命名冲突
* 代码复用
* 文件依赖

类似于 Java，JS 在模块化组织之后，通过 `import` 很容易的解决了命名冲突和代码复用的问题，就文件依赖而言，有一些规范，比如 CommonJS、AMD，直到 es6 才真正在语言层面上实现了模块化。

> CommonJS 与 es6 模块的异同。

| |CommonJS | es6|
| :--|:--:|:---:|
|输出 | 值的缓存，不动态更新 | 动态绑定，输出实时的值 |
|输入 | 运行时加载，整体加载模块然后读取指定对象 | 编译时加载，只加载指定对象，其他对象不加载 |

注意 es6 加载的对象是只读的，尽管可以新增属性，但是不建议这么做。另一方面，当模块整体加载时，整体加载所在的那个对象是不允许改变的，即不允许新增属性。

在 es6 中，使用 `export default` 时，对应的 `import` 可以不用花括号，否则必须使用。其实，`export default a` 的含义是将变量 `a` 的值赋予变量 `default`。

在 es6 中，提供了动态 `import()` 方法，可以进行运行时的异步加载。

## Q10：闭包。

闭包是由函数以及声明函数时的词法环境组合而成的。该环境包含了这个闭包环境创建时作用域内的任何局部变量。

```JavaScript
function MakeAdder(x) {
    return function(y) {
        return x + y;
    };
}

const add5 = MakeAdder(5);
const add10 = MakeAdder(10);

console.log(add5(2));       // 7
console.log(add10(20));     // 30
```

## Q11：防抖和节流

防抖和节流都是为了降低回调执行频率，节省计算资源，提高前端性能而设计的。

但不同点在于防抖是一段连续操作后最后处理一次回调，而节流是在一段连续操作中间隔执行回调。

其实现方法可以统一为如下框架：

```JavaScript
function debounce(fn, delay) {
    var timer = null;
    return function() {
        var _this = this; // 取 debounce 执行作用域的 this
        var _args arguments;
        if(timer)
        {
            // 防抖
            clearTimeout(timer);
            // 节流
            return;
        }
        timer = setTimeout(function() {
            fn.apply(_this, _args);
            // 节流
            timer = null;
        }, delay);
    };
}
```

## Q12：Promise 函数。

在异步编程中，如果事件之间存在依赖，就需要嵌套回调来满足依赖，如果嵌套的层数太多，可读性和可维护性都会很差，Promise 就通过**修改回调嵌套为链式执行**解决了这一问题，增加了可读性和可维护性。

## Q13：介绍 V8 引擎。

### JS 代码执行机制。

可分为四步：
* 预解析（主要进行语法检查）
* 生成 AST
* 生成字节码
* 生成机器码

### V8 垃圾回收机制

变量存储的位置主要有两种：堆内存和栈内存。栈中主要存储基本类型数据和引用类型数据的地址，堆中存储引用类型的数据。

栈内存在函数调用上下文切换后进行回收。

堆内存的回收机制为：
* 新生代内存，先扫描 FROM 回收非存活对象，存活对象复制到 TO，然后交换 FROM/TO。
* 老生代内存：晋升，标记清除，整理内存碎片

### V8 优化

* 优化 JIT：多次执行的字节码转化为机器码缓存。
* 隐藏类：借助类和偏移位置的思想，将对象进行分组，即隐藏类
* 内嵌缓存：缓存查询结果，完整查询过程为：获取隐藏类->查找偏移位置->计算属性地址。
* 垃圾回收机制。

## Q14：页面渲染时 JS 阻塞的解决方法。

在页面的解析过程中，如果遇到 `href='...'` 时，将其加入下载队列，继续解析 DOM，但遇到 `src='...'` 时，暂停 DOM 解析并立即下载脚本进行执行，脚本执行结束才继续解析 DOM。

避免阻塞的方法：
* 推迟加载：如果页面加载时并不依赖 JS，可以把引用外部文件的代码放在 `body` 的最后执行。
* defer 延迟加载：`<script src="" defer></script>`，在文档解析完成开始执行，在 DOMContentLoaded 事件之前执行完成，会按照顺序下载执行，效果和第一种一样。
* 异步加载：async 异步加载（不保证按顺序执行），动态创建 DOM 方式（用的最多的）

