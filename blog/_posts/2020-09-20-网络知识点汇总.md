---
title:          网络知识点汇总
date:           2020-09-20
author:         Echo
location:       Beijing 
tags: 
    - 面试
    - 网络
    - 前端
---

谈起计算机网络，不得不祭出这张图。

<div style="text-align: center">
    <img :src="$withBase('/2020-09-20-OSI-TCPIP.gif')", alt="2020-09-20-OSI-TCPIP", style="margin: 0 auto;"/>
</div>

## 1. 当浏览器输入一个url请求会经历什么？

主要流程大致如下：
* DNS 域名解析
* 建立 TCP 连接（三次握手）
* 发起 HTTP 请求（Request）
* 服务器处理请求，浏览器接受 HTTP 响应（Response）
* 浏览器解析渲染页面
* 连接结束（四次挥手）
下面解释下各部分。

贴一张画的很全面的图（来自https://juejin.im/post/6864175613209640973，侵删）。

<div style="text-align: center;">
    <img :src="$withBase('/2020-09-20-url.png')" alt="2020-09-20-url" style="margin: 0 auto;"/>
</div>

### 1.1 DNS 域名解析

浏览器 DNS 缓存 -> 本地 hosts 文件 -> 本地 DNS 解析器缓存 -> 本地 DNS 服务器（具有权威性）-> 非本地 DNS 服务器区域有缓存（不具有权威性）-> 本地 DNS 服务器迭代查询（根、二级、三级...），查询到之后，先缓存再返回给客户机。

### 1.2 三次握手

发送端 SYN = 1, seq = x -> 接收端 SYN = 1, ACK = 1, seq = y, ack= x + 1 -> 发送端 ACK = 1, seq = x + 1, ack = y + 1。

> 为什么TCP客户端最后还要发送一次确认呢？

主要是为了防止已经失效的连接请求报文突然又传到服务器，产生错误和资源浪费。

### 1.3 发起 HTTP 请求

完整的 HTTP 请求包括起始行、请求头部、请求主体三部分。
请求方法有：
* GET：获取资源
* POST：传输实体主体
* PUT：传输文件
* DELETE：删除文件
* HEAD：获取报文首部
* OPTIONS：询问支持的方法
* TRACE：追踪路径

GET 和 POST 的区别：
* GET 请求没有 body，只有 url，请求数据放在 url 的 querystring 中；POST 请求的数据在 body 中，通常来自于表单提交。
* 所以，GET 请求对访问数据没有副作用，POST 有副作用，就好比数据库中的查询和更新。
* 因此，GET 可以被缓存，而 POST 不能缓存，也不能被收藏为书签。

### 1.4 接收 HTTP 响应

服务器受到浏览器发送的 HTTP 请求后，会将 HTTP 报文封装成 HTTP 的 Request 对象，并通过不同的 Web 服务器进行处理，处理完的结果以 HTTP 的 Response 对象返回，主要包括状态码，响应头和响应报文三部分。

:warning: 注意，**TCP 规定**，
* SYN 报文段不能携带数据，但要消耗一个序号
* ACK 报文可以携带数据，但如果不携带数据则不消耗序号
* FIN 报文段可以携带数据，但即使不携带数据也要消耗一个序号。

> 为什么建立连接时三次握手而关闭连接要四次握手？

建立连接的时候，服务器在 LISTEN 状态下，收到建立连接请求的 SYN 的报文后，把 ACK 和 SYN 放在同一个报文段里发送给客户端。
而关闭连接的时候，服务器收到对方的 FIN 报文段，只是表示对方不再发送数据了但还能接收数据，此时服务器也未必已经发送完所有的数据了，因此服务器可以立即关闭，也可以发送完剩下的数据后再发送 FIN 报文段表示同意关闭连接，所以服务器的 ACK 和 FIN 一般都会分开发送，导致多了一次挥手。

> 如果已经建立了连接，但客户端故障了怎么办？

服务器设置了一个保活计时器来避免资源浪费，一般是 2 个小时，如果连接建立后一直没有收到客户端的数据，那么在保活计时器超时之后，服务器就会发送一个探测报文，以后每隔 75 分钟发送一个，若一连 10 个探测报文都没有回应，则服务器认为客户端故障，主动关闭连接。

### 1.5 浏览器解析渲染页面

* 构建文档对象模型（DOM）
* 构建 CSS 对象模型（CSSOM）
* 构建渲染树（Render Tree）
* 布局
* 绘制

### 1.6 关闭连接（四次挥手）

浏览器发完数据后，发送 FIN 请求断开连接 -> 服务器发送 ACK 表示同意 -> 服务器发送 FIN 请求断开连接 -> 浏览器发送 ACK 表示同意。

## 2. DNS 服务器

DNS 服务器分为三类：根 DNS 服务器，顶级域 DNS 服务器，权威 DNS 服务器。

DSN 查询有递归查询和迭代查询，其区别如下：
* 递归查询：必须返回一个准确的查询结果，如果该 DNS 服务器没有查到，那么就会成为代理去询问其他服务器。
* 迭代查询：DNS 服务器会像请求端返回其他能够解释查询的 DNS 服务器。

一般情况下，从请求主机到本地 DNS 服务器的查询是递归的，其余查询是迭代的。

## 3. TCP 与 UDP

### 3.1 优劣对比

| | TCP | UDP |
|:--|:--:|:--:|
|连接状态| 面向连接 | 无连接 |
| 可靠性 | 可靠交付 | 尽最大努力交付 |
| 实时性 | 效率比 UDP 低 | 实时性好 |
| 收发方 | 点对点 | 一对一/多，多对一/多都可 |
| 系统资源需求 | 较高 | 较少 |
| 备注 | TCP 通过流量控制、序号、确认和定时器，确保正确、按序将数据从发送进程交付给接收进程 | 适用于对高速传输和实时性要求较高的通信或广播通信，且对数据安全性无特殊要求 |

### 3.2 TCP 发送方

超时重传，快重传。

快重传：在某报文段的定时器过期之前重传丢失的报文段。

### 3.3 TCP 接收方

累计确认，差错恢复。

虽然 TCP 是累计确认（类似 Go-Back-N，GBN 协议），但是它会缓存失序报文段，且允许接收方有选择地确认失序报文段，这就使得发送方可以选择重传（类似 Select-Repeat，SR 协议）。
因此，TCP 的差错恢复机制为 GBN 协议和 SR 协议的混合体。

### 3.4 TCP 流量控制与拥塞控制

都是对发送方的遏制。

流量控制是流量控制也是一个速率匹配服务，是为了避免接收方缓存溢出的。它其实是一个速率匹配服务，让发送方发送但未被确认的数据量小于接收方的接收窗口大小（rwnd 是动态变化的），就可以保证接收方缓存不会溢出。

拥塞控制是一个全局性的过程，为了避免过多数据注入到网络中，保证路由器或链路不过载的。拥塞的标志可以说是重传计时器超时或接收到三个重复确认。相关算法有慢启动算法、拥塞避免算法（使网络比较不容易拥塞而不是完全避免）、快重传、快恢复。

## 4. HTTP 协议

HTTP 协议包括两种报文：请求（Request）报文和响应（Response）报文，[这里](https://juejin.im/post/6864175613209640973#heading-23)有很详细的解释。

https://juejin.im/post/6864175613209640973#heading-26